/**
 * Document Requirements - Single Source of Truth
 *
 * This file defines which post-launch tracking documents are required
 * at each gate. Both gates.ts and document-tools.ts import from here
 * to ensure consistency.
 *
 * TIMING MODEL:
 * - Documents are CREATED after a gate is approved (via init_gate_documents)
 * - Documents are REQUIRED at the NEXT gate (enforcement)
 *
 * Example: G1 docs (FEEDBACK_LOG, COST_LOG, PROJECT_CONTEXT)
 * - Created: After G1 approval, before starting G2 work
 * - Required: At G2 approval (enforcement check)
 *
 * MODIFICATION WARNING: Changes here affect both gate validation and
 * document initialization tools.
 */

import type { GateId } from '../state/truth-store.js';

// ============================================================================
// Document Specifications
// ============================================================================

export interface DocumentSpec {
  /** Template filename in templates/docs/ */
  template: string;
  /** Output path relative to project root */
  outputPath: string;
  /** Gate AFTER which this document should be created */
  creationGate: GateId;
  /** Gate at which this document is REQUIRED (enforcement) */
  requiredAtGate: GateId;
  /** Human-readable description */
  description: string;
  /** Whether document is required (vs optional) */
  required: boolean;
}

/**
 * Master document specifications - SINGLE SOURCE OF TRUTH
 *
 * TIMING:
 * - creationGate: When to create (after this gate is approved)
 * - requiredAtGate: When to enforce (must exist before this gate approval)
 */
export const DOCUMENT_SPECS: Record<string, DocumentSpec> = {
  FEEDBACK_LOG: {
    template: 'FEEDBACK_LOG.md',
    outputPath: 'docs/FEEDBACK_LOG.md',
    creationGate: 'G1',      // Create after G1 (scope) approval
    requiredAtGate: 'G2',    // Required before G2 (PRD) approval
    description: 'Tracks all user feedback throughout project lifecycle',
    required: true,
  },
  COST_LOG: {
    template: 'COST_LOG.md',
    outputPath: 'docs/COST_LOG.md',
    creationGate: 'G1',      // Create after G1 (scope) approval
    requiredAtGate: 'G2',    // Required before G2 (PRD) approval
    description: 'Tracks token usage and session costs',
    required: true,
  },
  PROJECT_CONTEXT: {
    template: 'PROJECT_CONTEXT.md',
    outputPath: 'docs/PROJECT_CONTEXT.md',
    creationGate: 'G1',      // Create after G1 (scope) approval
    requiredAtGate: 'G2',    // Required before G2 (PRD) approval
    description: 'Onboarding context for new team members',
    required: true,
  },
  CHANGE_REQUESTS: {
    template: 'CHANGE_REQUESTS.md',
    outputPath: 'docs/CHANGE_REQUESTS.md',
    creationGate: 'G2',      // Create after G2 (PRD) approval
    requiredAtGate: 'G3',    // Required before G3 (architecture) approval
    description: 'Tracks scope changes after PRD approval',
    required: true,
  },
  POST_LAUNCH: {
    template: 'POST_LAUNCH.md',
    outputPath: 'docs/POST_LAUNCH.md',
    creationGate: 'G9',      // Create after G9 (production) approval
    requiredAtGate: 'G10',   // Required before G10 (completion) approval
    description: 'Post-launch maintenance and evolution guide',
    required: false, // Only for projects that reach deployment
  },
  PRE_DEPLOYMENT_REPORT: {
    template: 'PRE_DEPLOYMENT_REPORT.md',
    outputPath: 'docs/PRE_DEPLOYMENT_REPORT.md',
    creationGate: 'G7',      // Create after G7 (security) approval - generated by Orchestrator
    requiredAtGate: 'G8',    // REQUIRED before G8 (pre-deployment) approval - BLOCKING
    description: 'Consolidates all development metrics for Go/No-Go decision',
    required: true,
  },
} as const;

export type DocumentName = keyof typeof DOCUMENT_SPECS;

// ============================================================================
// Gate-to-Document Mappings (Derived from DOCUMENT_SPECS)
// ============================================================================

/**
 * Get documents that should be CREATED at a specific gate
 */
export function getDocumentsForGate(gate: GateId): DocumentName[] {
  return Object.entries(DOCUMENT_SPECS)
    .filter(([_, spec]) => spec.creationGate === gate)
    .map(([name]) => name as DocumentName);
}

/**
 * Get document output paths REQUIRED at a specific gate
 * (for gate prerequisite validation / enforcement)
 */
export function getRequiredDocPathsForGate(gate: GateId): string[] {
  return Object.values(DOCUMENT_SPECS)
    .filter(spec => spec.requiredAtGate === gate && spec.required)
    .map(spec => spec.outputPath);
}

/**
 * Get all document output paths that should exist BY a specific gate
 * (cumulative - includes all previous gates)
 */
export function getRequiredDocPathsByGate(gate: GateId): string[] {
  const gateOrder: GateId[] = ['G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7', 'G8', 'G9', 'G10'];
  const gateIndex = gateOrder.indexOf(gate);

  if (gateIndex === -1) {
    // Handle E2 (enhancement gate) - only needs G1 docs
    if (gate === 'E2') {
      return getRequiredDocPathsForGate('G1');
    }
    return [];
  }

  const paths: string[] = [];
  for (let i = 0; i <= gateIndex; i++) {
    paths.push(...getRequiredDocPathsForGate(gateOrder[i]));
  }
  return paths;
}

/**
 * Pre-computed gate-to-documents mapping for performance
 */
export const GATE_DOCUMENTS: Record<string, DocumentName[]> = {
  G1: getDocumentsForGate('G1'),
  G2: getDocumentsForGate('G2'),
  G3: getDocumentsForGate('G3'),
  G4: getDocumentsForGate('G4'),
  G5: getDocumentsForGate('G5'),
  G6: getDocumentsForGate('G6'),
  G7: getDocumentsForGate('G7'),
  G8: getDocumentsForGate('G8'),
  G9: getDocumentsForGate('G9'),
  G10: getDocumentsForGate('G10'),
  E2: [], // Enhancement projects use G1 docs only
};

/**
 * Pre-computed gate-to-required-paths mapping for performance
 * Used by gates.ts for GATE_PREREQUISITES
 */
export const GATE_REQUIRED_TRACKING_DOCS: Record<string, string[]> = {
  G1: getRequiredDocPathsForGate('G1'),
  G2: getRequiredDocPathsForGate('G2'),
  G3: getRequiredDocPathsForGate('G3'),
  G4: getRequiredDocPathsForGate('G4'),
  G5: getRequiredDocPathsForGate('G5'),
  G6: getRequiredDocPathsForGate('G6'),
  G7: getRequiredDocPathsForGate('G7'),
  G8: getRequiredDocPathsForGate('G8'),
  G9: getRequiredDocPathsForGate('G9'),
  G10: getRequiredDocPathsForGate('G10'),
  E2: [],
};
