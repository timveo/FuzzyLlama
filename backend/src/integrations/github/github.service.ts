import { Injectable, BadRequestException } from '@nestjs/common';
import { Octokit } from '@octokit/rest';
import { PrismaService } from '../../common/prisma/prisma.service';
import { GitIntegrationService } from '../../code-generation/git-integration.service';
import { FileSystemService } from '../../code-generation/filesystem.service';

export interface GitHubRepoOptions {
  name: string;
  description?: string;
  private?: boolean;
  autoInit?: boolean;
}

export interface GitHubExportResult {
  success: boolean;
  repoUrl: string;
  repoName: string;
  filesExported: number;
  error?: string;
}

@Injectable()
export class GitHubService {
  constructor(
    private prisma: PrismaService,
    private gitIntegration: GitIntegrationService,
    private filesystem: FileSystemService,
  ) {}

  /**
   * Create Octokit instance with user's GitHub token
   */
  private getOctokit(accessToken: string): Octokit {
    return new Octokit({
      auth: accessToken,
    });
  }

  /**
   * Get authenticated user info
   */
  async getAuthenticatedUser(accessToken: string): Promise<any> {
    try {
      const octokit = this.getOctokit(accessToken);
      const { data } = await octokit.rest.users.getAuthenticated();
      return data;
    } catch (error) {
      throw new BadRequestException(
        'Failed to authenticate with GitHub: ' + error.message,
      );
    }
  }

  /**
   * Create a new GitHub repository
   */
  async createRepository(
    accessToken: string,
    options: GitHubRepoOptions,
  ): Promise<{ repoUrl: string; cloneUrl: string; repoName: string }> {
    try {
      const octokit = this.getOctokit(accessToken);

      // Create repository
      const { data } = await octokit.rest.repos.createForAuthenticatedUser({
        name: options.name,
        description: options.description || 'Generated by FuzzyLlama',
        private: options.private !== false, // Default to private
        auto_init: options.autoInit || false,
      });

      console.log(`[GitHub] Created repository: ${data.full_name}`);

      return {
        repoUrl: data.html_url,
        cloneUrl: data.clone_url,
        repoName: data.full_name,
      };
    } catch (error) {
      if (error.status === 422 && error.message.includes('already exists')) {
        throw new BadRequestException(
          `Repository '${options.name}' already exists on GitHub`,
        );
      }

      throw new BadRequestException(
        'Failed to create GitHub repository: ' + error.message,
      );
    }
  }

  /**
   * Check if repository exists
   */
  async repositoryExists(
    accessToken: string,
    owner: string,
    repo: string,
  ): Promise<boolean> {
    try {
      const octokit = this.getOctokit(accessToken);
      await octokit.rest.repos.get({ owner, repo });
      return true;
    } catch (error) {
      if (error.status === 404) {
        return false;
      }
      throw error;
    }
  }

  /**
   * Export project code to GitHub
   */
  async exportProjectToGitHub(
    projectId: string,
    userId: string,
    accessToken: string,
    repoName?: string,
  ): Promise<GitHubExportResult> {
    try {
      // Get project
      const project = await this.prisma.project.findUnique({
        where: { id: projectId },
        include: { owner: true },
      });

      if (!project) {
        throw new BadRequestException('Project not found');
      }

      if (project.ownerId !== userId) {
        throw new BadRequestException(
          'You can only export your own projects',
        );
      }

      // Check if project already exported
      if (project.githubRepoUrl) {
        return {
          success: true,
          repoUrl: project.githubRepoUrl,
          repoName: project.githubRepoUrl.split('/').slice(-1)[0],
          filesExported: 0,
          error: 'Project already exported to GitHub',
        };
      }

      // Generate repository name if not provided
      const finalRepoName =
        repoName || this.generateRepoName(project.name || project.id);

      // Get authenticated user
      const githubUser = await this.getAuthenticatedUser(accessToken);

      // Create GitHub repository
      const { repoUrl, cloneUrl } = await this.createRepository(accessToken, {
        name: finalRepoName,
        description: `FuzzyLlama Project: ${project.name || 'Untitled'}`,
        private: true,
      });

      console.log(
        `[GitHub Export] Created repository: ${repoUrl} for project ${projectId}`,
      );

      // Initialize Git in project workspace if not already done
      const initResult = await this.gitIntegration.initRepository(projectId);

      if (!initResult.success && !initResult.error?.includes('already')) {
        throw new Error('Failed to initialize Git: ' + initResult.error);
      }

      // Commit all files
      const commitResult = await this.gitIntegration.commitAll(
        projectId,
        'Initial commit - Generated by FuzzyLlama',
        {
          name: project.owner.name || 'FuzzyLlama User',
          email: project.owner.email,
        },
      );

      if (!commitResult.success && commitResult.error !== 'No files to commit') {
        throw new Error('Failed to commit files: ' + commitResult.error);
      }

      // Add remote and push
      const pushResult = await this.gitIntegration.addRemoteAndPush(
        projectId,
        cloneUrl.replace('https://', `https://${accessToken}@`), // Use token for auth
        'main',
      );

      if (!pushResult.success) {
        throw new Error('Failed to push to GitHub: ' + pushResult.error);
      }

      // Update project with GitHub info
      // Note: Project schema only has githubRepoUrl, not githubRepoName
      await this.prisma.project.update({
        where: { id: projectId },
        data: {
          githubRepoUrl: repoUrl,
        },
      });

      console.log(
        `[GitHub Export] Successfully exported ${commitResult.filesCommitted} files to ${repoUrl}`,
      );

      return {
        success: true,
        repoUrl,
        repoName: `${githubUser.login}/${finalRepoName}`,
        filesExported: commitResult.filesCommitted,
      };
    } catch (error) {
      console.error('[GitHub Export] Error:', error);
      return {
        success: false,
        repoUrl: '',
        repoName: '',
        filesExported: 0,
        error: error.message,
      };
    }
  }

  /**
   * Push updates to existing GitHub repository
   */
  async pushUpdatesToGitHub(
    projectId: string,
    userId: string,
    accessToken: string,
    commitMessage?: string,
  ): Promise<GitHubExportResult> {
    try {
      // Get project
      const project = await this.prisma.project.findUnique({
        where: { id: projectId },
        include: { owner: true },
      });

      if (!project) {
        throw new BadRequestException('Project not found');
      }

      if (project.ownerId !== userId) {
        throw new BadRequestException('You can only update your own projects');
      }

      if (!project.githubRepoUrl) {
        throw new BadRequestException(
          'Project not yet exported to GitHub. Use export endpoint first.',
        );
      }

      // Check for uncommitted files
      const uncommittedFiles =
        await this.gitIntegration.getUncommittedFiles(projectId);

      if (uncommittedFiles.length === 0) {
        // Extract repo name from URL
        const repoName = project.githubRepoUrl?.split('/').slice(-2).join('/') || '';
        return {
          success: true,
          repoUrl: project.githubRepoUrl,
          repoName,
          filesExported: 0,
          error: 'No changes to push',
        };
      }

      // Commit changes
      const commitResult = await this.gitIntegration.commitAll(
        projectId,
        commitMessage || 'Update - Generated by FuzzyLlama',
        {
          name: project.owner.name || 'FuzzyLlama User',
          email: project.owner.email,
        },
      );

      if (!commitResult.success) {
        throw new Error('Failed to commit files: ' + commitResult.error);
      }

      // Push to remote
      const cloneUrl = project.githubRepoUrl.replace(
        'https://github.com',
        'https://github.com',
      );
      const pushResult = await this.gitIntegration.addRemoteAndPush(
        projectId,
        cloneUrl.replace('https://', `https://${accessToken}@`),
        'main',
      );

      if (!pushResult.success) {
        throw new Error('Failed to push to GitHub: ' + pushResult.error);
      }

      console.log(
        `[GitHub Update] Pushed ${commitResult.filesCommitted} files to ${project.githubRepoUrl}`,
      );

      // Extract repo name from URL
      const repoName = project.githubRepoUrl?.split('/').slice(-2).join('/') || '';
      return {
        success: true,
        repoUrl: project.githubRepoUrl,
        repoName,
        filesExported: commitResult.filesCommitted,
      };
    } catch (error) {
      console.error('[GitHub Update] Error:', error);
      return {
        success: false,
        repoUrl: '',
        repoName: '',
        filesExported: 0,
        error: error.message,
      };
    }
  }

  /**
   * Get repository info
   */
  async getRepositoryInfo(
    accessToken: string,
    owner: string,
    repo: string,
  ): Promise<any> {
    try {
      const octokit = this.getOctokit(accessToken);
      const { data } = await octokit.rest.repos.get({ owner, repo });
      return {
        name: data.name,
        fullName: data.full_name,
        description: data.description,
        url: data.html_url,
        cloneUrl: data.clone_url,
        private: data.private,
        defaultBranch: data.default_branch,
        createdAt: data.created_at,
        updatedAt: data.updated_at,
      };
    } catch (error) {
      throw new BadRequestException(
        'Failed to get repository info: ' + error.message,
      );
    }
  }

  /**
   * List user's repositories
   */
  async listUserRepositories(
    accessToken: string,
    page = 1,
    perPage = 30,
  ): Promise<any[]> {
    try {
      const octokit = this.getOctokit(accessToken);
      const { data } = await octokit.rest.repos.listForAuthenticatedUser({
        page,
        per_page: perPage,
        sort: 'updated',
        direction: 'desc',
      });

      return data.map((repo) => ({
        name: repo.name,
        fullName: repo.full_name,
        description: repo.description,
        url: repo.html_url,
        private: repo.private,
        updatedAt: repo.updated_at,
      }));
    } catch (error) {
      throw new BadRequestException(
        'Failed to list repositories: ' + error.message,
      );
    }
  }

  /**
   * Create README.md with project metadata
   */
  async createReadme(projectId: string): Promise<string> {
    const project = await this.prisma.project.findUnique({
      where: { id: projectId },
      include: {
        owner: true,
        gates: {
          where: { status: 'APPROVED' },
          orderBy: { approvedAt: 'asc' },
        },
      },
    });

    if (!project) {
      return '';
    }

    const readme = `# ${project.name || 'FuzzyLlama Project'}

Project generated by FuzzyLlama AI

## Project Information

- **Type**: ${project.type}
- **Created**: ${project.createdAt.toLocaleDateString()}
- **Owner**: ${project.owner.name || project.owner.email}
- **Generated by**: [FuzzyLlama](https://fuzzyllama.dev)

## Gates Approved

${project.gates.map((gate) => `- âœ… ${gate.gateType} (${gate.approvedAt.toLocaleDateString()})`).join('\n')}

## Tech Stack

<!-- Add tech stack details here -->

## Getting Started

### Prerequisites

- Node.js 18+
- npm or yarn

### Installation

\`\`\`bash
npm install
\`\`\`

### Development

\`\`\`bash
npm run dev
\`\`\`

### Build

\`\`\`bash
npm run build
\`\`\`

### Test

\`\`\`bash
npm run test
\`\`\`

---

ðŸ¤– Generated with [FuzzyLlama](https://fuzzyllama.dev) - AI-Powered Software Factory
`;

    // Write README to workspace
    await this.filesystem.writeFile(projectId, 'README.md', readme);

    return readme;
  }

  /**
   * Generate repository name from project name
   */
  private generateRepoName(projectName: string): string {
    return projectName
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '')
      .substring(0, 100);
  }
}
